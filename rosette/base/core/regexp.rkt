#lang racket

(require "term.rkt" "union.rkt" "bool.rkt" "polymorphic.rkt" "safe.rkt")

(provide @regexp?)

(define (regexp/equal? x y)
  (match* (x y)
    [((? regexp?) (? regexp?)) (equal? x y)]
    [(_ _) (=? x y)]))

(define-lifted-type @regexp?
  #:base regexp?
  #:is-a? (instance-of? regexp? @regexp?)
  #:methods
  [(define (solvable-default self) #rx"$.^")
   (define (type-eq? self u v) (regexp/equal? u v)) 
   (define (type-equal? self u v) (regexp/equal? u v))
   (define (type-cast self v [caller 'type-cast])
     (match v
       [(? regexp?) v]
       [(term _ (== self)) v]
       [(union : [g (and (app type-of (== @regexp?)) u)] _ ...) (assert #f)] ;TODO don't know what to do here
       [_ (@assert #f (thunk (raise-argument-error caller "expected a regexp?" v)))])) 
   (define (type-compress self force? ps) regexp/compress)])     

; TODO not sure what I need here, for now just using generic
(define (regexp/compress force? ps)
  (generic-merge* ps))

; Temporary, for development reference:
;Operation 	Brief description
;(str.to.re s) 	Convert string to regular expression accepting s.
;(str.in.re s r) 	Determine if s is in the language generated by r.
;re.allchar 	The regular expression accepting every string.
;re.nostr 	The regular expression rejecting every string.
;(re.range ch1 ch2) 	The range of characters between ch1 and ch2.
;(re.++ r1 r2 r3) 	Concatenation of regular expressions.
;(re.* r) 	Kleene star.
;(re.+ r) 	Kleene plus.
;(re.opt r) 	Zero or one use of r.
;((_ re.loop lo hi) r) 	from lo to hi number of repetitions of r.
;(re.union r1 r2) 	The union of regular languages.
;(re.inter r1 r2) 	The intersection of regular languages.
;(seq.to.re s) 	Convert sequenceto regular expression accepting s.
;(seq.in.re s r) 	Determine if sequence s is in the language generated by r.
;(as re.all R) 	The regular expression of sort R accepting every sequence.
;(as re.empty R) 	The regular expression of sort R rejecting every sequence.