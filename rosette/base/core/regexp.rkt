#lang racket

(require "term.rkt" "union.rkt" "bool.rkt" "polymorphic.rkt" "safe.rkt"
         "string.rkt")

(provide @regexp? @regexp-quote @regexp-match-exact? @string->regexp)

(define (regexp/equal? x y)
  (match* (x y)
    [((? regexp?) (? regexp?)) (equal? x y)]
    [(_ _) (=? x y)]))

(define-lifted-type @regexp?
  #:base regexp?
  #:is-a? (instance-of? regexp? @regexp?)
  #:methods
  [(define (solvable-default self) #rx"$.^")
   (define (type-eq? self u v) (regexp/equal? u v)) 
   (define (type-equal? self u v) (regexp/equal? u v))
   (define (type-cast self v [caller 'type-cast])
     (match v
       [(? regexp?) v]
       [(term _ (== self)) v]
       [(union : [g (and (app type-of (== @regexp?)) u)] _ ...) (assert #f)] ;TODO don't know what to do here
       [_ (@assert #f (thunk (raise-argument-error caller "expected a regexp?" v)))])) 
   (define (type-compress self force? ps) regexp/compress)])     

; TODO not sure what I need here, for now just using generic
(define (regexp/compress force? ps)
  (generic-merge* ps))

;; ----------------- Lifting utilities ----------------- ;;

; TODO duplicate logic in string.rkt, consolidate at some point

(define (safe-apply-n op xs @ts?)
  (define caller (object-name op)) 
  (cond
    [(empty? @ts?) (apply op (for/list ([x xs]) (type-cast @regexp? x caller)))]
    [else (apply op (for/list ([x xs] [@t? @ts?]) (type-cast @t? x caller)))]))

(define (safe-apply-1 op x @ts?)
  (safe-apply-n op (list x) @ts?))

(define (safe-apply-2 op x y @ts?)
  (safe-apply-n op (list x y) @ts?))

(define (lift-op op . ts)
  (case (procedure-arity op)
    [(1)  (lambda (x) (safe-apply-1 op x ts))]
    [(2)  (lambda (x y) (safe-apply-2 op x y ts))]
    [else
     (case-lambda
       [() (op)]
       [(x) (safe-apply-1 op x ts)]
       [(x y) (safe-apply-2 op x y ts)]
       [xs (safe-apply-n op xs ts)])]))

(define T*->regexp? (const @regexp?))

;; ----------------- Regexp Operators ----------------- ;;

; Comments are temporary, for development purposes

; Things people may want that we don't need directly for Z3:
; regexp-match
; regexp-match*
; regexp-try-match
; regexp-match?
; regexp-split
; regexp-replace
; regexp-replace*
; regexp-replaces
; regexp-replace-quote

(define ($regexp str)
  (if (string? str)
      (regexp str)
      (expression @regexp str)))

(define-operator @regexp
  #:identifier 'regexp
  #:range T*->regexp?
  #:unsafe regexp
  #:safe (lift-op $regexp @string?))

; Z3 operations
;(str.to.re s) 	Convert string to regular expression accepting s.
(define ($regexp-quote str [case-sensitive? #t])
  (if (string? str)
      (regexp-quote str case-sensitive?)
      (expression @regexp-quote str case-sensitive?)))

(define-operator @regexp-quote
  #:identifier 'regexp-quote
  #:range T*->string?
  #:unsafe $regexp-quote
  #:safe
  (lambda (str [case-sensitive? #t]) 
    (define caller 'regexp-quote)
    ($regexp-quote
     (type-cast @string? str caller)
     case-sensitive?)))

(define ($string->regexp str)
  (@regexp (@regexp-quote str)))

(define-operator @string->regexp
  #:identifier 'string->regexp
  #:range T*->regexp?
  #:unsafe $string->regexp
  #:safe (lift-op $string->regexp @string?))

;(str.in.re s r) 	Determine if s is in the language generated by r.
(define ($regexp-match-exact? pattern input)
  (if (and ((or/c string? regexp?) pattern) (string? input)) 
      (regexp-match-exact? pattern input)
      (expression @regexp-match-exact? pattern input)))

; TODO need (or/c @string? regexp?) for 1st arg eventually
(define-operator @regexp-match-exact?
  #:identifier 'regexp-match-exact?
  #:range T*->boolean?
  #:unsafe $regexp-match-exact?
  #:safe (lift-op $regexp-match-exact? @regexp? @string?))

;re.allchar 	The regular expression accepting every string.
; TODO 

;re.nostr 	The regular expression rejecting every string.
; TODO #rx"$.^"

; All of the heavy lifting for these will happen in enc.rkt:
;(re.range ch1 ch2) 	The range of characters between ch1 and ch2.
;(re.++ r1 r2 r3) 	Concatenation of regular expressions.
;(re.* r) 	Kleene star.
;(re.+ r) 	Kleene plus.
;(re.opt r) 	Zero or one use of r.
;((_ re.loop lo hi) r) 	from lo to hi number of repetitions of r.
;(re.union r1 r2) 	The union of regular languages.
;(re.inter r1 r2) 	The intersection of regular languages.

;Will need to get string from regexp, and then do some magic
; Maybe need some sort of macro for #rx syntax to just be (regexp)

